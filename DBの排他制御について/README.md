# DBの排他制御について

## 排他制御について
- 排他制御：複数のユーザやトランザクションが同時に同じデータを操作できないようにする仕組み
- トランザクション：関連する複数の処理を１つの処理単位としてまとめたもの
- 排他制御が目指すもの
  - データ整合性の維持
  - スループットの最大化
- 排他制御されていなければ、複数ユーザが同じデータを同時に更新するとデータ整合性が崩れる
- 排他制御されていても、設計が甘いとスループットが低下する

<br>

## 排他制御を実現するための技術要素

### 技術要素
- 物理ロック
  - DBMSで実現されているロック機構。
  - 共有ロック、更新ロック、排他ロックなどがある。
- 論理ロック
  - アプリケーションレイヤーで実現するロック機構。
  - 複数のトランザクションに跨るロックを実現する。
  - 楽観的ロック、悲観的ロックがある。
- トランザクション分離レベル
  - トランザクションを同時実行したときの独立性を決定するレベル
  - 分離レベルが高いほど色々な不都合な読み取りを防ぐことができるが、スループットは低下する
- これらをどう組み合わせるかが排他制御設計

<br>

### 物理ロック
#### 共有ロック
- データ読み出し時にかけるロック
- 他トランザクションは参照のみ可能
- 他トランザクションは同じデータに対して、共有・更新ロックを取得可能

#### 排他ロック
- データ更新時にかけるロック
- 他トランザクションは参照更新不可
- 他トランザクションは同じデータに対して、どんなロックも取得不可
  - しかし実用上不便なので共有ロックはできるようになっている
  - 分離レベルがread uncommittedの時は共有ロック取得可能

#### 更新ロック
- データ取得時に更新予定であればかけるロック
- 更新が始まると排他ロックになる
- 更新ロック中は他トランザクションは参照のみ可能
- 共有ロックで実現しようとすると、排他ロックの取り直しが必要
  - 更新目的で参照するなら初めから更新ロックを使う
- 他トランザクションは同じデータに対して、共有ロックを取得可能

#### トランザクション分離レベル
- 分離レベルの種類(高い順)
  - serializable
    - 全てのトランザクションを時間的重なりなく実行
  - repeatable read
    - 他トランザクションで変更されることのないデータを読み取る
    - MySQLではデフォルト
  - read committed
    - commit済みのデータを常に読み取る
    - 最低限「dirty read」は防ぐべきなので、ほとんどのDBのデフォルト
    - これより上のレベルだとスループットが著しく低下する
    - 同じトランザクション内で同一データを検索することは基本的にはないので
    「non repeatable read」や「phantom read」は発生しない
  - read uncommitted
    - commit前のデータも読み取り可能
- 不都合な読み取りの種類
  - dirty read
    - 他トランザクションで更新したcommit前のデータを読み取る
    commit前のデータはロールバックされる可能性があるので絶対に避けるべき
  - non repeatable read
    - あるトランザクションで同じデータを２回読み込んだ際に、
    １回目と２回目の間に更新が行われるとデータが異なる
  - phantom read
    - あるトランザクションで同じ条件でデータを２回検索した際に、
    １回目と２回目の間に登録が行われるとレコード件数が異なる

<br>

### 論理ロック
物理ロックは１つのトランザクションの制御だが、業務は基本的に複数のトランザクションで構成されるため
物理ロックだけではデータの整合性の維持はできない。
例えば、ユーザAが画面でデータを入力中(トランザクション外)に別のユーザが同じデータを更新するケースなど。
- 楽観的ロック方式
  - 更新データ参照時に更新チェック値も一緒に保持しておき、更新を実行するときにチェック値が変更されていないことを確認する。
    - 更新チェック方法は２つ
      - update文の条件式にチェック値を入れる方法
        - 参照からupdate実行までに他ユーザから更新されていたら、それまでに別システムなどに依頼した処理のロールバックが必要になる
      - 更新ロックをかける方法
        - 更新ロック中は他ユーザから排他ロックをかけられないので、
        更新ロック以後の処理は無駄にならない
  - メリット
    - 悲観的ロック方式よりも実現コストが低い
  - デメリット
    - 参照と更新の間に他ユーザが同一データを更新すると、エラーにするため入力が無駄になる
    - チェック値をテーブルカラムに持たせ、セッションにも保持する必要がある
  - 使い所
    - 複数ユーザが同時に同じデータを更新する可能性が低い場合
    - ユーザが入力したデータが無駄になっても、ユーザの損害が少ない場合
- 悲観的ロック方式
  - ユーザが編集作業を始める前に、他のユーザが更新できないようにロックしてしまう。
    - ロックテーブルを用意しておき、操作開始時にレコードを登録し、終了時に削除する
    - ロックテーブルにレコードがあればロックされていると判断する
  - ロックしたまま画面遷移や、ブラウザを閉じるとロックが開放されない
    - 対策
      - ログイン、ログアウト時にレコードを削除
      - 有効期限切れのレコードを定時バッチなどで削除または無視する
      - 権限ユーザが強制解除可能にする
  - メリット
    - ユーザの入力が無駄にならない
  - デメリット
    - 実装の手間がかかる
  - 使い所
    - 他のユーザによる更新処理の中断を、完全に防がなければならない場合
      - 入力量が多く無駄にしたくない
      - 複数ユーザが同一のデータを操作する可能性が高い

<br>

### 排他制御単位

#### 排他制御単位の設計
常に一緒に更新されるテーブル同士は１つの単位とみなし、
それぞれ排他制御を行わなくてもそのうちの代表テーブルのみ排他制御を行えば十分。
業務要件とER図からこの単位を設計する

#### 更新順序の設計
複数のトランザクションが勝手な順番でテーブルを更新することでデッドロックが発生する。
これは排他制御単位間で更新順序を決めることで防止できるが、システムでは強制できないので
開発者間でルールを作り、守る必要がある。

<br>

## 排他制御設計の考え方
処理が行われる時間の間隔が大きい状況から、徐々に短い状況を想定し、
あらゆる競合パターンを検討する

### 実例１　オンライン処理とバッチ処理の並走
ユーザはいつでも会員の情報を更新でき、
バッチは全会員情報に対して１時間かけて更新処理を行うケース
- 考慮１：バッチ更新時に前会員レコードをロックすると、ユーザは更新できなくなる
  - 対策：更新レコードごとにトランザクションを分けてロックするレコードを１件のみにする
- 考慮２：画面上で会員情報を編集中にバッチが対象データを更新した場合、画面上の編集が終了すると値を更新してしまう
  - 対策：楽観的ロックでバッチの更新を上書きされないようにする
- 考慮３：バッチ処理が先に排他ロックを取得し、ユーザが画面上の編集内容で更新をかけようとした場合
  - バッチのロック解放後に画面上のトランザクションで更新可否チェックを行い、バッチ処理を検知する。排他制御上問題なし
- 考慮４：画面上での更新ロック取得後にバッチが排他ロックを取得しようとした場合
  - 画面上での更新が完了したらバッチが排他ロックをかけ、更新する。排他制御上問題なし


### 実例２ 常駐バッチの並列実行
２つのサーバで同じ処理を行う常駐バッチを並列実行し、
1つの同じテーブルに対して更新処理を行う。

- 考慮１：バッチが同じレコードを食い合う
  - 対策：更新する前に再取得しステータスが「未処理」であることを確認する
  このときに更新ロックをかけることで「再取得後に別バッチで再取得されて食い合うケース」を避けられる。
- 考慮２：処理に失敗した場合に、そのトランザクション内でNG回数をインクリメントする処理を行うと、最後にロールバックを行うのでかき消されてしまう
  - 対策：処理に失敗したらまずロールバックし、新しいトランザクションでNG回数更新する
  しかし、トランザクションを分けることでバッチBが入り込む隙が生まれる
- 考慮３：処理失敗時のトランザクションの隙間にバッチBの処理が入り込み、失敗した場合
  - 対策：バッチA側ではNG回数の加算をせずに終了すれば、１回多くリトライすることになるが問題ない
- 考慮４：処理失敗時のトランザクションの隙間にバッチBの処理が入り込み、成功した場合
  - 問題：バッチAのNG回数更新トランザクションが後続するため、成功したレコードにNGをつけてしまう
  - 対策１：NG回数更新トランザクション内で、ステータスが未処理の場合のみ更新を行う
  - 対策２：トランザクション内でトランザクションをネストし、業務更新処理を子トランザクションで行う


<br>

## メモ
イミュータブルデータモデルを意識して設計したらそもそも更新が少ないはずなので、
基本的には更新が比較的多そうなリソーステーブルに対して楽観的ロックを実現すればよさそう
> 「楽観的ロックでいいじゃん！」と思える理由は主に４つ挙げられます。
> （理由１）ユーザの認証と認可をきちんと処理していれば、更新の競合というのはほとんどありえない
> （理由２）業務上、同一行を複数人で同時に更新するプロセスはほとんど考えられない
> （理由３）動的に変化するデータを対照表の形で作成してしまえば、追加のみなので、ロックは必要ない
> （理由４）データの所有権を管理すれば、更新の競合は、ほとんどありえない
> [楽観的ロックでいいじゃん！](http://web.archive.org/web/20080206132246/http://blogs.sqlpassj.org/akiraonishi/articles/5026.aspx)


<br>


以下の記事と「データベースの排他制御」のスライドでは悲観的ロックの実現手段が違っている。。
悲観的ロックはあくまで考え方ということか？
> (悲観的ロックの実現手段は)「SELECT FOR UPDATE」によってデータを取得して更新する
> [アプリにおける排他制御 -楽観的/悲観的ロックの違いと使い所-](https://qiita.com/wanko5296/items/464a444418d0ec81971a)