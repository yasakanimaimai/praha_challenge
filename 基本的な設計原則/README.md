# 基本的な設計原則

## 課題1 

<br>

### SOLID原則の各要素を、業務経験1年目のITエンジニアに伝わるように説明してください。
- 単一責任の原則
  - モジュール(クラスやメソッドなど、特定の機能を持ったひとまとまりのプログラム)は、
  １つの責任だけを持つようにプログラムを設計するべきというソフトウェア設計の原則の１つ。
  - モジュールが複数の責任を持ってしまうと、
    - １つの修正が別の箇所に影響を与えてバグが発生しやすくなり、バグを防ぐためのコストがかかる。
    - 修正するにあたって開発者は影響範囲に注意を配る必要があるので、ストレスがかかる。
  - 「１つの責任」がどこまでカバーするかを判断する基準として
  「モジュールを修正する際の理由が１つであること」が挙げられる。
    - 例えば会員登録制のECシステムがあり、ユーザに関する責任をUserクラスが担当していたとする。
    Userクラスはbuyメソッドを持ち、非会員ユーザも会員ユーザも共通してこのbuyメソッドを使用している。
    もしも会員ユーザだけ割引を適用したいという要望があった場合、buyメソッドを修正する必要がある。
    会員と非会員というステータスをUserクラスに持たせて、buyメソッド内でswitch文によるロジックの切り替えを行うような修正をする場合、
    修正理由は「会員ユーザに割引を適用する」と「非会員ユーザに割引を適用しない」の２つであるため、
    buyメソッド、ひいてはUserクラスは単一責任の原則に違反していると考えられる。

- オープンクローズドの原則
  - プログラムを修正する際に、既存のコードを修正せず、
  コードを追加することで対応できるようにすべきというソフトウェア設計の原則の１つ。
  - 既存のコードを修正すると、それが使用されている箇所でバグを生む可能性があるので、それを防ぐのが目的。
  - 上記のECサイトの例では、もしユーザの会員ステータスの種類が増えた場合、
  swich文のケースを増やしてしまうような修正は既存のコードを修正しているのでこの原則に反していると考えられる。

- リスコフの置換原則
  - 子クラスはその親クラスに置き換えられても、その振る舞い(インスタンス化に必要な引数の数やメソッドの戻り値の型)が変わらないようにすべきというソフトウェア設計の原則の１つ。
  - オブジェクト指向の長所として、同じ型のモジュールなら交換可能であることが挙げられるが、この原則に違反するとその長所が十分に機能しなくなる。
  - 例えば親クラスのメソッドaが文字列を返すのに対し、親クラスを継承した子クラスのメソッドaの戻り値が数値だった場合、クラスを利用する側は親と子の両ケースに対応する必要ある。言い換えるとクラスを利用する側の対応が無ければ親と子は交換可能ではない。


- インターフェイス分離の原則
  - あるインターフェイスを実装するクラス内で、インターフェイスが持つメソッドを一部しか使わないようなときは、クラスで全てのメソッドが使われるようにインターフェイスを分離すべきというソフトウェア設計の原則の１つ。
  - 使用しないメソッドだとしても実装を強いられるので余分なコードが増えるし、本来不要なはずの変更の可能性も高まる。


- 依存性逆転の原則
  - 利用する側のモジュールと利用される側のモジュールは、インターフェイスを介して結合されるべきとするソフトウェア設計の原則の１つ。
  - 中間にインターフェイスを導入することでモジュール間の依存度を弱めることができる。
  - またオブジェクト指向の長所である「同じ型のモジュールなら交換可能であること」を実現するためにも必要になる。
  - 例えばメソッドaの引数としてクラスBのインスタンスが指定されているとする。
  もし今後「状況に応じてクラスCのインスタンスを使いたい」という要望が挙がったとき、メソッドaを修正する必要がある。ここでクラスBではなくクラスBが実装しているインターフェイスを引数に指定すると、クラスCも同じインターを実装すればメソッドaを修正せずに使うことができる。

### これらを守ることで、どのようなメリットがあるのでしょうか？
ソフトウェア開発の大きな課題である「保守性」を維持することができる。
- 単一責任の原則
  - 修正が必要な箇所を特定しやすくなる
  - 変更の影響を予測しやすくなる
  - モジュールを利用しやすくなる
- オープンクローズドの原則
  - 修正後に既存コードで発生するバグを減らすことができる
  - 機能の追加が容易になる
- リスコフの置換原則
  - 親クラスを見れば子クラスの振る舞いをそれぞれ意識しなくてよくなる
  - 機能の追加が容易になる
- インターフェイス分離の原則
  - 修正が必要な箇所を特定しやすくなる
- 依存性逆転の原則
  - モジュールを利用しやすくなる
  - コード修正しやすくなる

<br>

### 単一責任の原則と、単純にファイルを細かなファイルに分解することには、どのような違いがあるでしょうか？
単一責任の原則の場合は分割の基準が「モジュールの役割」で、
単純なファイル分けの場合は分割の基準が「コード量」になると思う。
前者の場合、モジュールが役割を複数持ちそうな時点で分割を意識するが、
後者の場合はコード量が増えてから分割を意識する。
しかしコード量が増えてから分割するのはコストが大きいので
最終的に前者の方が手間が少なくて済むと考えられる。

<br>

### Open-Closed-Principleの実例を一つ考えて、作成してみてください。
### TS Playgroundで書けるような簡単なサンプルで構いません！
`./nodejs/src/ocp/correct.ts`に記載

<br>

### リスコフの置換原則に違反した場合、どのような不都合が生じるでしょうか？
この原則に違反すると、親クラスと子クラスが交換できないということで、
つまり兄妹クラスとも交換できないということなので、
オブジェクト指向の長所である「同じ型のモジュールなら交換可能であること」が十分に機能しない。

<br>

### インターフェイスを用いる事で、設計上どのようなメリットがあるでしょうか？
- 具体的な実装に依存することなく設計を進められる
- インターフェースを見ると実装の振る舞いを知ることができる
- 実装と実装の間にインターフェースがあることで、互いの依存度を小さくできる

<br>

### どんな時に依存性の逆転を用いる必要が生じるのでしょうか？
- テストなどで、メソッド内部で使用されているモジュールの動きを外から制御したい場合

<br>

### デメトルの法則とは何でしょうか？業務経験1年目のITエンジニアに伝わるように説明してください。
### この法則を守ることで、どのようなメリットがあるのでしょうか？
あるオブジェクトの中で他のオブジェクトのプロパティのプロパティやメソッドにアクセスするようなことはせず、
引数で渡されたオブジェクトのプロパティやメソッドまでに留めた方がいいというソフトウェア設計の考え方。
違反しているイメージとしては、モジュールA.モジュールB.モジュールC...という感じ。
上記のような書き方をしているモジュールは、
「モジュールAはモジュールBを持ち、モジュールBはモジュールCを持つこと」を前提としているため
モジュール同士が密結合になっている。
この法則を守ると、モジュール間の結合度が下がるため、
修正の影響が最小限で済んだりバグが発生する可能性が下がる。

<br>

## 課題2

### このコードにはどのような問題点が潜んでいるでしょうか？
- PurchaseServiceがPurchaseのプロパティにアクセスしているのはデメテルの法則に違反する

### もしあなたが書き換えるとしたら、どのようにこのコードを改修しますか？
- `./nodejs/src/challenge2/index.ts`に修正結果を記載

<br>

## 課題3

### Personクラスの名前と勤務開始日（name, starWorkingAt）は外部から自由に書き換えられるような状態になっています。この設計にはどのような問題が潜んでいるでしょうか
publicなフィールドはどこで値が書き変わっている可能性があるため、
本当に求める値が入っているかがわからない。そのため利便性が落ちる。

<br>

### どうすれば解決できると思いますか？
- publicではなく、private修飾子を付ける。

### なぜgetter/setterをつけても問題は解決しないのか？
getter/setterをつけても外側からフィールドを変更することは許容しているので
本質的には変わらないから。








## 参考記事 & メモ
> [TypeScriptでSOLID原則〜単一責任の原則〜 | メンバーズエッジカンパニーブログ](https://www.membersedge.co.jp/blog/typescript-solid-single-responsibility-principle/)
> - 単一責任の原則とは、ソフトウェアを構成する個々のモジュールが責任を負う対象は、
たったひとつにするべきであるという原則です。

> [TypeScriptでSOLID原則〜開放閉鎖の原則〜 | メンバーズエッジカンパニーブログ](https://www.membersedge.co.jp/blog/typescript-solid-open-closed-principle/)
> - 開放閉鎖の原則とは、ソフトウェアを構成するモジュールは、拡張に対して開いていて（Open）、
修正に対して閉じている（Closed）べきであるという原則です。
つまり、ソフトウェアに新しく機能を追加するとき、
既存のコードを変更せず新しいコードを追加するだけで済むようにしておくべきであるという意味です。
> - すでに動作しているコードに変更を加えると、バグを生んでしまう可能性があり、
バグを生まないために動作確認を行うなどのコストを支払う必要があります。

> [TypeScriptでSOLID原則〜リスコフの置換原則〜 | メンバーズエッジカンパニーブログ](https://www.membersedge.co.jp/blog/typescript-solid-liskov-substitution-principle/)
> - 部品Tとその派生型である部品Sがあるとき、部品Tが使われている箇所はすべて部品Sで置換可能になるように部品Sはつくられているべきであるという原則です。
> - リスコフの置換原則では、スーパータイプとサブタイプが置換可能であるとき、以下の2つのルールに則っているとされています。
>   - サブタイプの事前条件はスーパータイプと同一か、それよりも弱めることができる（事前条件をスーパータイプより強めることは出来ない）
>   - サブタイプの事後条件はスーパータイプと同一か、それよりも強めることができる（事後条件をスーパータイプより弱めることは出来ない）
> - 事前条件とは、ある操作が実行される直前の状態で満たすべき条件のことです。
「事前条件を弱める」というのは、たとえば、インスタンス生成のために必要な引数の数を少なくするなどがあります。
> - 事後条件とは、ある操作が実行された直後の状態で満たすべき条件のことです。
「事後条件を強める」というのは、たとえば、メソッド実行後に変更されていなければならないプロパティの数を増やすなどがあります。
> - 原則に違反してはいけない理由
>   - スーパータイプとサブタイプの関係を置換可能なものにしていない場合、
ソフトウェアの拡張性というオブジェクト指向設計の大きなメリットを享受できなくなってしまいます。
また、置換可能でないスーパークラスとサブクラスの関係を作ってしまったことによりバグが生まれる可能性もあります。
> - リスコフの置換原則は、調べると「S型とT型が〜」とか「契約プログラミングの文脈では〜」など、結構難しい言葉で説明されがちですが、
要は「親の決まりを子が破ってはいけない」という、クラス設計のルールだと私は考えています。


> [TypeScriptでSOLID原則〜インターフェイス分離の原則〜 | メンバーズエッジカンパニーブログ](https://www.membersedge.co.jp/blog/typescript-solid-interface-segregation-principle/)
> - インターフェイス分離の原則とは、インターフェイスとクライアント（インターフェイスの利用者）がいるときに、
インターフェイスに用意されてある不必要なメソッドやプロパティ（利用するクライアントにとって不必要）にクライアントが依存しなくてもよいように、
分割できるインターフェイスは分割するべきであるという原則です。
> - クライアントが不必要なメソッドに依存しているということは、
クライアントが知る必要がない情報を持ってしまっているということです。
たとえばインターフェイスが変更になった場合は（クライアントが関係しない部分であっても）
その変更に引っ張られてクライアントも修正しなければいけなくなったりします。
> - 注意が必要な点として、この原則はどのような場面でも必ず有効であるとは限らないということを意識する必要があります。
たとえば、プロパティが互いに整合性を保つように設計されていて、
それぞれの値を単独で扱うべきではないようなクラスについては、
インターフェイスは分離せずにクラスをそのまま渡したほうがよい場合もあります。

> [TypeScriptでSOLID原則〜依存性逆転の原則〜 | メンバーズエッジカンパニーブログ](https://www.membersedge.co.jp/blog/typescript-solid-dependency-inversion-principle/)
> - 依存性逆転の原則とは、あるモジュールが別のモジュールを利用するとき、モジュールはお互いに直接依存すべきではなく、どちらのモジュールも、共有された抽象（インターフェイスや抽象クラスなど）に依存すべきであるという原則です。
> - モジュールAがモジュールBの実装を参照していた場合、モジュールBの変更がモジュールAに影響を及ぼす可能性があります。そのため、モジュールBの改修を行う際は、モジュールBの実装に依存しているモジュールAに影響がないかなどの調査を行わねばならず、そのぶん工数がかかってしまいます。
> 

> [リスコフの置換原則（LSP）をしっかり理解する - Qiita](https://qiita.com/yuki153/items/142d0d7a556cab787fad)
> - サブタイプの振る舞いはこうあるべきだ」という１つの指針がリスコフの置換原則と言えます。

> [【オブジェクト指向】「リスコフの置換原則」について | プログラミングマガジン](http://www.code-magagine.com/?p=17058)
> - サブクラスの動きを知っておかないとクライアントコードで使うことができなくなってしまう点です。（クライアント側で知識が必要になってしまう）。なので、クライアント側でこのサブクラスを使う場合はというような条件分岐が出てきかねない作りになってしまい保守性が下がります。
> - 知識はできるだけサブクラス側に隠蔽して抽象はただ、「ファクトリクラスを使って生成して抽象化されたメソッドを呼ぶ」ということだけに意識が持てるような設計にします。
> 

> [インターフェイス分離の原則を考える](https://zenn.dev/maru44/articles/3405308b1b83bc)
> 皆重複を排除したがるけれど、その重複は 本物の重複 ですか?
> 本物の重複 : あるインスタンスに変更があればそのインスタンスのすべての複製にも同じ変更を反映しなければならない。
> 偽物の重複 : 明らかに重複していたコードが時間とともに異なる真価をとげて、数年後には全く違うものになっている。

> [デメテルの法則 - Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%A1%E3%83%86%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87)
> - あるオブジェクトAは別のオブジェクトBのサービスを要求してもよい（メソッドを呼び出してもよい）が、オブジェクトAがオブジェクトBを「経由して」さらに別のオブジェクトCのサービスを要求してはならない。これが望ましくないのは、オブジェクトAがオブジェクトBに対して、オブジェクトB自身の内部構造以上の知識を要求してしまうためである。 このような場合には、クラスBを変更し、クラスAがクラスBに対して行った要求を適切なBのサブコンポーネントに伝播させるようにすればよい。
> - 簡単な例として、犬を散歩に連れ出すことを考える。この際、犬の足に直接「歩け」と命じるのはおかしいだろう。
この場合は、犬に対して命令し、自分の足の面倒は自分で見させるのが正しい方法だといえる。
> - デメテルの法則の利点としては、結果的にソフトウェアがよりメンテナンスしやすく、柔軟なものになりやすいという点が挙げられる。オブジェクトが他のオブジェクトの内部構造に依存することが少なくなるため、オブジェクトのコンテナを呼び出し側の変更なしに修正することができる。
> - マルチレイヤアーキテクチャは、ソフトウェアシステムにおいてデメテルの法則を系統的に実装するためのメカニズムとして捉えることができる。 レイヤ化されたアーキテクチャにおいて、各レイヤ中のコードは自分の属するレイヤと直下のレイヤのコードのみを呼び出すことができる。直下のレイヤをスキップして他のレイヤにアクセスした場合には、アーキテクチャに違反していることになる。

> [カプセル化とは？～安全なシステムを作る為の配慮～｜オブジェクト指向プログラミング(OOP)をおさらいしよう（４） - GiXo Ltd.](https://www.gixo.jp/blog/5914/)
> OOPにおけるカプセル化には何が求められているのでしょうか？
> - OOPにおけるカプセル化は、分割した処理を「その処理を利用してくれる他のプログラム」に対して「公開する」OR「隠ぺいする」という手法を自身のプログラムに対して盛り込む事である
> - これは他者に対して「余計な処理を見せて惑わせない」「処理の意図しない使われ方をさせない」という配慮である
> - この「配慮」がオブジェクト(≒プログラム)同士の信頼関係を築きあげ、安全なシステムを作る土台となる

> [結局のところgetter／setterは要るのか？要らないのか？ - Qiita](https://qiita.com/katolisa/items/6cfd1a2a87058678d646)
> - 「Tell, Don't Ask.」とは、オブジェクト指向プログラミングにおいて"良い"とされる考え方のひとつ。
日本語だと大体「求めるな、命じよ」と訳されることが多い。
もうちょっと具体的にすると、ある処理をする際、その処理に必要な情報をオブジェクトから引き出さないで、情報を持ったオブジェクトにその処理をさせろということ。getterというのはまさにオブジェクトから情報を引き出すメソッドである。つまり、あるクラスで他クラスのgetterを呼び出すような処理を実装している場合、その処理は本来呼び出されるクラス側で実装されるべきだということ。
setterも同様に、フィールドの中身を変えるような処理はそもそもそのフィールドをもつクラス内で完結させるべきである、という考え方。



- [イラストで理解するSOLID原則 - Qiita](https://qiita.com/baby-degu/items/d058a62f145235a0f007)
- [interfaceとtypeの違い、そして何を使うべきかについて](https://zenn.dev/luvmini511/articles/6c6f69481c2d17)
- [クリーンアーキテクチャ完全に理解した](https://gist.github.com/mpppk/609d592f25cab9312654b39f1b357c60)
- [実践クリーンアーキテクチャ with Java │ nrslib](https://nrslib.com/clean-architecture-with-java/#outline__4)