# 基本的な設計原則

## 課題 1

### SOLID 原則の各要素について

#### 単一責任の原則

クラスやモジュールの責務は 1 つにすべきという考え。
複数の責務を持つクラスは、そのクラスの修正が複数の箇所に影響を与えてバグが発生しやすくなる。
すると、修正による影響範囲の調査やバグの発生に対してコストがかかる。

**Q1. 責務が 1 つとはどういうことか？**
クラスが関わるユースケースのアクターが 1 つであること。
アクターとは、「概念に対する視点」や「変更要求の出発点」とも言い換えられる。
現実的には「システムのユーザ」や「外部システム」にあたる。
EC システムを例に考える。ユースケースとして管理者による商品明細の閲覧と、購入者による商品カタログの閲覧があり、それぞれの機能で同じ 1 つの商品クラスを使っているとする。この商品クラスは複数のアクターと関係があるため、管理者からの変更要求による商品クラスの修正が、購入者のユースケースで使用される商品クラスに影響を与える可能性がある。

**Q2. 原則の具体的な実現方法は？**
ユースケース洗い出し時に同じ名前の概念が出てきた時は、アクターが同じかどうか注意する

#### オープンクローズドの原則

追加仕様があった際に、既存コードの変更ではなく、新規コードの追加で対応できるようにすべきという考え。既存コードを変更すると、それが使用されている箇所でバグを生む可能性があるので、それを防ぐのが目的。

**Q1. 原則の具体的な実現方法は？**
抽象クラスやインターフェースを利用する。特に以下のようなテクニックがある。

- ストラテジーパターン： 条件によって複数の処理を切り替えて実行するようなケースで有効
- デコレーターパターン： オブジェクトに対して複数の処理を組み合わせて実行するようなケースで有効
- 依存性の注入： オブジェクトが依存しているオブジェクトを外部から渡せるようなケースで有効

#### リスコフの置換原則

サブクラスは基底クラスに置き換えられても、その振る舞い(インスタンス化に必要な引数の数やメソッドの戻り値の型)が変わらないようにすべきという考え。例えば基底クラスのメソッド a が文字列を返すのに対し、基底クラスを継承したサブクラスのメソッド a の戻り値が数値だった場合、クラスを利用する側は親と子の両ケースに対応する必要がある。
要するに、クライアント側は基底クラスの振る舞いだけ知っていれば、サブクラスを使えるようにしておきたい。

**Q1. 基底クラスに存在しないメソッドをサブクラスに定義してはいけない？**
protected や private のアクセス修飾子を使い、外部に公開しないのであれば OK。
または、コンポジションパターンを利用して、追加したい機能を持ったクラスとサブクラスをインスタンス変数として保持した新しいオブジェクトを作成する。
どうしても public なメソッドを追加したい場合は基底クラスに定義し、すべてのサブクラスで実装する

#### インターフェイス分離の原則

あるインターフェイスを実装するクラス内で、インターフェイスが持つメソッドを一部しか使わないようなときは、クラスで全てのメソッドが使われるようにインターフェイスを分離すべきという考え。使用しないメソッドがあるということは、インターフェイス内で複数の関心ごとを扱っている可能性がある。また使用しないコードの実装を強いられるので余分なコードが増えるし、本来不要なはずの修正の可能性も高まる。

**Q1. 一部のサブクラスだけすべてのメソッドを使用しないような場合はどうする？**
そのサブクラスで使用されるメソッドと使用されないメソッドをそれぞれ持つインターフェイスに分割し、他のサブクラスでは両方のインターフェイスを実装し、対象のサブクラスでは使用されるメソッドだけを定義したインターフェイスを実装する。

#### 依存性逆転の原則

クライアントコードと依存関係にあるモジュールは、インターフェイスを介して結合されるべきという考え。
中間にインターフェイスを導入することでモジュール間の依存度を弱めることができる。
例えばメソッド 1 の引数としてクラス A のインスタンスが指定されているとする。今後「状況に応じてクラス B のインスタンスを使いたい」という変更があったとき、メソッド 1 を修正する必要がある。しかし、メソッド 1 の引数として、クラス A ではなくクラス A が実装しているインターフェイスを引数に指定しておくと、クラス B も同じインターフェイスを実装していれば、メソッド 1 を修正する必要がなくなる。

### これらを守ることで、どのようなメリットがあるのでしょうか？

ソフトウェア開発の大きな課題である「保守性」を維持することができる。

- 単一責任の原則
  - コードを理解しやすくなる
  - 修正が必要な箇所を特定しやすくなる
  - 変更の影響を予測しやすくなる
  - モジュールを利用しやすくなる
- オープンクローズドの原則
  - 修正後に既存コードで発生するバグを減らすことができる
  - 機能の追加が容易になる
- リスコフの置換原則
  - 基底クラスを見ればサブクラスの振る舞いをそれぞれ意識しなくてよくなる
  - 機能の追加が容易になる
- インターフェイス分離の原則
  - コードを理解しやすくなる
  - 修正が必要な箇所を特定しやすくなる
- 依存性逆転の原則
  - モジュールを利用しやすくなる
  - インフラに近いコードでも差し替えなどの修正がしやすくなる

<br>

### 単一責任の原則と、単純にファイルを細かなファイルに分解することには、どのような違いがあるでしょうか？

単一責任の原則の場合は分割の基準が「責務」で、
単純なファイル分けの場合は分割の基準が「コード量」になると思う。
前者の場合、モジュールが役割を複数持ちそうな時点で分割を意識するが、
後者の場合はコード量が増えてから分割を意識する。
しかしコード量が増えてから分割するのはコストが大きいので
最終的に前者の方が手間が少なくて済むと考えられる。

<br>

### Open-Closed-Principle の実例を一つ考えて、作成してみてください。

### TS Playground で書けるような簡単なサンプルで構いません！

`./nodejs/src/ocp/correct.ts`に記載

<br>

### リスコフの置換原則に違反した場合、どのような不都合が生じるでしょうか？

この原則に違反すると、親クラスと子クラスを交換する際にクライアントコードに修正が必要になる可能性がある。兄妹クラスと交換するときも同様。クライアントコードが持つべきでないコードや知識が増える。

<br>

### インターフェイスを用いる事で、設計上どのようなメリットがあるでしょうか？

- 具体的な実装に依存することなく設計を進められる
- インターフェースを見るとモジュールの振る舞いを知ることができる
- 実装と実装の間にインターフェースがあることで、互いの依存度を小さくできる

<br>

### どんな時に依存性の逆転を用いる必要が生じるのでしょうか？

- テストなどで、メソッド内部で使用されているモジュールの動きを外から制御したいとき
- 将来的に違うデータベースを使う可能性があるとき

<br>

### デメトルの法則とは何でしょうか？業務経験 1 年目の IT エンジニアに伝わるように説明してください。

オブジェクトが他のオブジェクトにアクセスするときは、深い階層のプロパティやメソッドにアクセスすべきではないという考え。違反しているイメージとしては、object.item.user.name という感じ。
上記のような書き方をしているモジュールは、「object は item を持ち、item は user を持ち、user は name を持つ」ことを前提としているためモジュール同士が密結合になっている。

### この法則を守ることで、どのようなメリットがあるのでしょうか？

この法則を守ると、モジュール間の結合度が下がるため、修正の影響が最小限で済んだり、バグが発生する可能性が下がる。

<br>

## 課題 2

### このコードにはどのような問題点が潜んでいるでしょうか？

- 購入データのトランザクションが成功しているかどうかというシステム上の都合の情報がドメインロジックに混ざっている
  - 抽象度にばらつきがあるので読みにくい
- すべての購入履歴をメモリ上に展開するのはパフォーマンス的に不安
- Purchase メソッドが購入不可判定の内部ロジックを持っており、詳細へ依存している。
- PurchaseSurveice が purchase の内部プロパティにアクセスしているのでデメテルの法則にも違反してる？

### もしあなたが書き換えるとしたら、どのようにこのコードを改修しますか？

`./nodejs/src/challenge2/index.ts`に改修コードを記載

- トランザクションの成否と期間はクエリで絞り込む
  - トランザクションの成否はビジネスロジックには関係ないので、アプリケーションコードで表現する必要はないと考える(paymentRecordRepo の実装で transaction.succeeded: true でいいのでは？)
  - 期間はビジネスロジックに関係するが、DB で期間を絞る方がシンプルだし、購入数が多ければパフォーマンスの不安がある
- 購入可否判定用のクラスを作成し、判定条件を隠蔽する
  - 購入可否に関するルールは将来的に追加や変更が予想されるのでクラスの方がいいと考える

<br>

## 課題 3

### Person クラスの名前と勤務開始日（name, startWorkingAt）は外部から自由に書き換えられるような状態になっています。この設計にはどのような問題が潜んでいるでしょうか

name や startWorkingAt に想定している値が入っている確証が持てない。
また想定値が入っていない場合にどこで入り込んだかを探すのに手間が掛かる。

<br>

### どうすれば解決できると思いますか？

public ではなく、private 修飾子を付ける。
もし名前を変更したいときは、その Person インスタンスを削除して、新しく Person インスタンスを作成する

### なぜ getter/setter をつけても問題は解決しないのか？

getter/setter をつけても自由なアクセスを許容しているので本質的には変わらないため。
getter/setter をつけそうになったときは、利用する側が求めている値を提供するメソッドを作り、それを呼び出す方向で考える。

## 任意課題

### 凝集度

- 関数内の機能の純粋度を示す尺度
- 理解のしやすさと修正時の影響度に関わる
- 高レベルの凝集を目指すべきだが、低レベルになった場合は関数を分割することでできるだけ高レベルにできる場合がある
- 凝集度が高い順
  - 機能的凝集：1 つの機能だけを持つ状態
  - 逐次的凝集：2 つ以上の関連性の高い機能があり、その順番に意味があり、分割してもあまり意味がない状態。ある機能の出力が次の機能の入力になるようなイメージ。
  - 通信的凝集：あるデータ処理のための関連性の高い機能が複数あり、その順序に強い制限はない状態
  - 手順的凝集：単に順番になっている処理を 1 つの関数にまとめられた状態。このレベルから再利用性がめっちゃ落ちてくる
  - 一時的凝集：特定の時点でのみ実行される機能が、時間的に近いという理由だけで集まっている状態
  - 論理的凝集：関数に含まれる機能が呼び出し側から選択される状態
  - 偶発的凝集：関数に含まれる機能に何の脈絡も関連もない状態

### 結合度

- 呼び出し関係にある関数間の結びつき度を示す尺度
- 修正時の副作用や関数の再利用性に関わる
- なるべくデータ結合を目指すべし
- 結合度が低い順
  - メッセージ結合：引数なし
  - データ結合：プリミティブレベルのデータだけを受け渡している状態
  - スタンプ結合：データの中で使用されない要素が含まれている状態(使用されない要素が多いのは NG)
  - 制御結合：データの中で処理を分岐するための要素がある状態(必然的にその関数は論理的凝集になる)
  - ハイブリッド結合：受け渡されるデータの意味が状況により異なること
  - 共通結合：グローバルデータで受け渡している状態
  - 内部結合：自身のデータが他の関数から直接操作できる状態

## 参考記事 & メモ

> [TypeScript で SOLID 原則〜単一責任の原則〜 | メンバーズエッジカンパニーブログ](https://www.membersedge.co.jp/blog/typescript-solid-single-responsibility-principle/)
>
> - 単一責任の原則とは、ソフトウェアを構成する個々のモジュールが責任を負う対象は、
>   たったひとつにするべきであるという原則です。

> [TypeScript で SOLID 原則〜開放閉鎖の原則〜 | メンバーズエッジカンパニーブログ](https://www.membersedge.co.jp/blog/typescript-solid-open-closed-principle/)
>
> - 開放閉鎖の原則とは、ソフトウェアを構成するモジュールは、拡張に対して開いていて（Open）、
>   修正に対して閉じている（Closed）べきであるという原則です。
>   つまり、ソフトウェアに新しく機能を追加するとき、
>   既存のコードを変更せず新しいコードを追加するだけで済むようにしておくべきであるという意味です。
> - すでに動作しているコードに変更を加えると、バグを生んでしまう可能性があり、
>   バグを生まないために動作確認を行うなどのコストを支払う必要があります。

> [TypeScript で SOLID 原則〜リスコフの置換原則〜 | メンバーズエッジカンパニーブログ](https://www.membersedge.co.jp/blog/typescript-solid-liskov-substitution-principle/)
>
> - 部品 T とその派生型である部品 S があるとき、部品 T が使われている箇所はすべて部品 S で置換可能になるように部品 S はつくられているべきであるという原則です。
> - リスコフの置換原則では、スーパータイプとサブタイプが置換可能であるとき、以下の 2 つのルールに則っているとされています。
>   - サブタイプの事前条件はスーパータイプと同一か、それよりも弱めることができる（事前条件をスーパータイプより強めることは出来ない）
>   - サブタイプの事後条件はスーパータイプと同一か、それよりも強めることができる（事後条件をスーパータイプより弱めることは出来ない）
> - 事前条件とは、ある操作が実行される直前の状態で満たすべき条件のことです。
>   「事前条件を弱める」というのは、たとえば、インスタンス生成のために必要な引数の数を少なくするなどがあります。
> - 事後条件とは、ある操作が実行された直後の状態で満たすべき条件のことです。
>   「事後条件を強める」というのは、たとえば、メソッド実行後に変更されていなければならないプロパティの数を増やすなどがあります。
> - 原則に違反してはいけない理由
>   - スーパータイプとサブタイプの関係を置換可能なものにしていない場合、
>     ソフトウェアの拡張性というオブジェクト指向設計の大きなメリットを享受できなくなってしまいます。
>     また、置換可能でないスーパークラスとサブクラスの関係を作ってしまったことによりバグが生まれる可能性もあります。
> - リスコフの置換原則は、調べると「S 型と T 型が〜」とか「契約プログラミングの文脈では〜」など、結構難しい言葉で説明されがちですが、
>   要は「親の決まりを子が破ってはいけない」という、クラス設計のルールだと私は考えています。

> [TypeScript で SOLID 原則〜インターフェイス分離の原則〜 | メンバーズエッジカンパニーブログ](https://www.membersedge.co.jp/blog/typescript-solid-interface-segregation-principle/)
>
> - インターフェイス分離の原則とは、インターフェイスとクライアント（インターフェイスの利用者）がいるときに、
>   インターフェイスに用意されてある不必要なメソッドやプロパティ（利用するクライアントにとって不必要）にクライアントが依存しなくてもよいように、
>   分割できるインターフェイスは分割するべきであるという原則です。
> - クライアントが不必要なメソッドに依存しているということは、
>   クライアントが知る必要がない情報を持ってしまっているということです。
>   たとえばインターフェイスが変更になった場合は（クライアントが関係しない部分であっても）
>   その変更に引っ張られてクライアントも修正しなければいけなくなったりします。
> - 注意が必要な点として、この原則はどのような場面でも必ず有効であるとは限らないということを意識する必要があります。
>   たとえば、プロパティが互いに整合性を保つように設計されていて、
>   それぞれの値を単独で扱うべきではないようなクラスについては、
>   インターフェイスは分離せずにクラスをそのまま渡したほうがよい場合もあります。

> [TypeScript で SOLID 原則〜依存性逆転の原則〜 | メンバーズエッジカンパニーブログ](https://www.membersedge.co.jp/blog/typescript-solid-dependency-inversion-principle/)
>
> - 依存性逆転の原則とは、あるモジュールが別のモジュールを利用するとき、モジュールはお互いに直接依存すべきではなく、どちらのモジュールも、共有された抽象（インターフェイスや抽象クラスなど）に依存すべきであるという原則です。
> - モジュール A がモジュール B の実装を参照していた場合、モジュール B の変更がモジュール A に影響を及ぼす可能性があります。そのため、モジュール B の改修を行う際は、モジュール B の実装に依存しているモジュール A に影響がないかなどの調査を行わねばならず、そのぶん工数がかかってしまいます。

> [リスコフの置換原則（LSP）をしっかり理解する - Qiita](https://qiita.com/yuki153/items/142d0d7a556cab787fad)
>
> - サブタイプの振る舞いはこうあるべきだ」という１つの指針がリスコフの置換原則と言えます。

> [【オブジェクト指向】「リスコフの置換原則」について | プログラミングマガジン](http://www.code-magagine.com/?p=17058)
>
> - サブクラスの動きを知っておかないとクライアントコードで使うことができなくなってしまう点です。（クライアント側で知識が必要になってしまう）。なので、クライアント側でこのサブクラスを使う場合はというような条件分岐が出てきかねない作りになってしまい保守性が下がります。
> - 知識はできるだけサブクラス側に隠蔽して抽象はただ、「ファクトリクラスを使って生成して抽象化されたメソッドを呼ぶ」ということだけに意識が持てるような設計にします。

> [インターフェイス分離の原則を考える](https://zenn.dev/maru44/articles/3405308b1b83bc)
> 皆重複を排除したがるけれど、その重複は 本物の重複 ですか?
> 本物の重複 : あるインスタンスに変更があればそのインスタンスのすべての複製にも同じ変更を反映しなければならない。
> 偽物の重複 : 明らかに重複していたコードが時間とともに異なる真価をとげて、数年後には全く違うものになっている。

> [デメテルの法則 - Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%A1%E3%83%86%E3%83%AB%E3%81%AE%E6%B3%95%E5%89%87)
>
> - あるオブジェクト A は別のオブジェクト B のサービスを要求してもよい（メソッドを呼び出してもよい）が、オブジェクト A がオブジェクト B を「経由して」さらに別のオブジェクト C のサービスを要求してはならない。これが望ましくないのは、オブジェクト A がオブジェクト B に対して、オブジェクト B 自身の内部構造以上の知識を要求してしまうためである。 このような場合には、クラス B を変更し、クラス A がクラス B に対して行った要求を適切な B のサブコンポーネントに伝播させるようにすればよい。
> - 簡単な例として、犬を散歩に連れ出すことを考える。この際、犬の足に直接「歩け」と命じるのはおかしいだろう。
>   この場合は、犬に対して命令し、自分の足の面倒は自分で見させるのが正しい方法だといえる。
> - デメテルの法則の利点としては、結果的にソフトウェアがよりメンテナンスしやすく、柔軟なものになりやすいという点が挙げられる。オブジェクトが他のオブジェクトの内部構造に依存することが少なくなるため、オブジェクトのコンテナを呼び出し側の変更なしに修正することができる。
> - マルチレイヤアーキテクチャは、ソフトウェアシステムにおいてデメテルの法則を系統的に実装するためのメカニズムとして捉えることができる。 レイヤ化されたアーキテクチャにおいて、各レイヤ中のコードは自分の属するレイヤと直下のレイヤのコードのみを呼び出すことができる。直下のレイヤをスキップして他のレイヤにアクセスした場合には、アーキテクチャに違反していることになる。

> [カプセル化とは？～安全なシステムを作る為の配慮～｜オブジェクト指向プログラミング(OOP)をおさらいしよう（４） - GiXo Ltd.](https://www.gixo.jp/blog/5914/)
> OOP におけるカプセル化には何が求められているのでしょうか？
>
> - OOP におけるカプセル化は、分割した処理を「その処理を利用してくれる他のプログラム」に対して「公開する」OR「隠ぺいする」という手法を自身のプログラムに対して盛り込む事である
> - これは他者に対して「余計な処理を見せて惑わせない」「処理の意図しない使われ方をさせない」という配慮である
> - この「配慮」がオブジェクト(≒ プログラム)同士の信頼関係を築きあげ、安全なシステムを作る土台となる

> [結局のところ getter／setter は要るのか？要らないのか？ - Qiita](https://qiita.com/katolisa/items/6cfd1a2a87058678d646)
>
> - 「Tell, Don't Ask.」とは、オブジェクト指向プログラミングにおいて"良い"とされる考え方のひとつ。
>   日本語だと大体「求めるな、命じよ」と訳されることが多い。
>   もうちょっと具体的にすると、ある処理をする際、その処理に必要な情報をオブジェクトから引き出さないで、情報を持ったオブジェクトにその処理をさせろということ。getter というのはまさにオブジェクトから情報を引き出すメソッドである。つまり、あるクラスで他クラスの getter を呼び出すような処理を実装している場合、その処理は本来呼び出されるクラス側で実装されるべきだということ。
>   setter も同様に、フィールドの中身を変えるような処理はそもそもそのフィールドをもつクラス内で完結させるべきである、という考え方。

> [オブジェクト指向設計　 getter, setter を使うなとはどういうことか - Qiita](https://qiita.com/Yahagi_pg/items/1bf59fc75d7f17c3b731)
> ・データの加工は、そのデータの持ち主がやるのがベスト。その結果、カプセル化が進み、コードの重複を排除できる
> ・カプセル化の目的は、変更による影響範囲を極力狭くすること

- [単一責任の原則（Single responsibility principle）について、もう一度考える | オブジェクトの広場](https://www.ogis-ri.co.jp/otc/hiroba/others/OOcolumn/single-responsibility-principle.html)
- [イラストで理解する SOLID 原則 - Qiita](https://qiita.com/baby-degu/items/d058a62f145235a0f007)
- [interface と type の違い、そして何を使うべきかについて](https://zenn.dev/luvmini511/articles/6c6f69481c2d17)
- [クリーンアーキテクチャ完全に理解した](https://gist.github.com/mpppk/609d592f25cab9312654b39f1b357c60)
- [実践クリーンアーキテクチャ with Java │ nrslib](https://nrslib.com/clean-architecture-with-java/#outline__4)
- [Getter, Setter の存在意義 | とわいらいと・せれなーで](https://yukki99.wordpress.com/2009/11/17/getter-setter-%E3%81%AE%E5%AD%98%E5%9C%A8%E6%84%8F%E7%BE%A9/)
- [凝集度と結合度](https://www.affordd.jp/koha_hp/KeyWords/KW.Coupling.html)
- [良いコードとは何か - エンジニア新卒研修 スライド公開｜ CyberZ Developer ｜ note](https://note.com/cyberz_cto/n/n26f535d6c575)
