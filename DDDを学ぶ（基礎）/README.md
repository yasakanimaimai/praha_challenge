# DDD を学ぶ（基礎）

## 課題 1

### エンティティ

- ドメインモデルを表現するオブジェクト
- ID によって同一判定が可能
- ID 以外のプロパティは可変
- 例: 社員番号を持つ社員、製造番号を持つ PC、ISO 国名コードが振られた国など

### 値オブジェクト（バリューオブジェクト）

- ドメインモデルを表現するオブジェクト
- 保持する値が全て同じ場合に同一判定が可能
- 例: 人の名前、性別、体重や、店の住所、面積、売上などが挙げられる
  - しかし、ドメイン次第でエンティティか値オブジェクトかは変わる

### 集約

- 強い整合性を持ったエンティティと値オブジェクトのまとまり
- リポジトリの単位になる。集約内のオブジェクトは同じにトランザクション内でデータ操作を行う
- 1 つの集約に対して、その大元になる 1 つのエンティティを集約ルートという
- 大きすぎる集約はトランザクションコストやロックによる遅延の影響が大きくなる
- 同じ集約内ならインスタンス参照、集約外なら ID 参照
- 複数集約を跨ぐ場合はいくつかの対応がある(1 つの集約に入れてしまうのはダメ)
  - ドメインイベントを使う
  - 整合性を保持するようなドメインサービスを作る

### ユビキタス言語

- 開発者、ドメインエキスパート、ドキュメント、モデル図で共通して使用する言語集

### 境界づけられたコンテキスト

- モデルを適用する区切りのこと
- 大規模システムなどで、同じ単語が持つ意味や属性が違う場合に、コンテキストごとに異なるモデルを適用する
  - 例: 販売と配送という文脈では、同じ「商品」に対する観点の違いから、モデルが保持する属性も違ってくる
- コンテキスト同士を繋げることをコンテキストマッピングという
- モデリングの途中に同じ単語が複数の意味を持ってきた段階でコンテキストを考えてみる
- コンテキストごとに 1 アプリケーション(マイクロサービス)として考える
  - DB は 1 アプリケーションに 1 つと考える。少なくともスキーマは分ける
  - マイクロサービスにするほどの規模ではない場合でもディレクトリは分ける(ディレクトリごとにオニオンアーキテクチャ構成ができるイメージ)

### ドメイン

- ソフトウェアで問題解決しようとする対象領域

### ドメインサービス

- ドメインオブジェクトにすると違和感があるビジネスロジックを格納する
- ドメインオブジェクトの集合に対する操作などはここ
- 極力使わず、ドメインオブジェクトにできないか考える(ドメインモデル貧血症を引き起こす要因になるため)

### リポジトリ

- エンティティ・値オブジェクトを永続化機構(DB など)に対して入出力するオブジェクト
- 入出力は必ず集約単位で行う
- 集約ルートというエンティティを起点にデータを参照し、集約ルート単位でリポジトリを用意する。

### アプリケーション（ユースケース）

- ドメインオブジェクトを組み合わせてユースケースを実現させる

### CQS/CQRS（似ているため、違いを重点的に調べてみましょう）

- CQS はメソッドの観点でコマンドとクエリを同時に行うべきではないという原則。DDD にはドメイン層レベルで適用できる？
- CQRS はアーキテクチャ観点でコマンドとクエリの役割を明確に分けて設計する方法。モデリングの際に読み込みと書き込みを別々に整理できる？

### DTO

- オニオンアーキテクチャなどの各階層間でデータをやり取りする際にオブジェクトを詰め替えを行うオブジェクト
- 層ごとに依存関係をリセットすることができる

### ドメインモデル貧血症

- ドメイン知識がドメイン層から溢れてアプリケーション内に散在している状態
- ドメインサービスを使いすぎたり、アプリケーション層にロジックが多いと起こりがち

<br>

## 課題 2

### 境界づけられたコンテキストの例

- 店舗運営システムにおける店舗コンテキストの「注文」と受発注コンテキストの「注文」
  - そもそも別のものを指しているので「注文」という命名を変えるべき？

### Human エンティティ

`./Human` 参照
Blood.ts の型チェックのより良い方法を知りたい

各プロパティを基本データ型ではなく値オブジェクトにする理由

- プロパティごとに責務を分散できる
- プロパティごとにテストしやすくなる
- Human エンティティの肥大化を抑えられる

<br>

## 課題 3

### 「ドメイン知識が漏れている」とはどういうこと？

ドメイン層にあるべき知識がユースケース層や UI 層に存在している状態のこと。

`./DomainLeakSample`参照

ListItems.usecase.ts でドメイン知識が漏れている点

- item が status に ACTIVE を持っていることを知っている
- item のリストを取得する際に、status:ACTIVE で暗黙的にフィルターをかけている

サンプルコードの例では、Item の集合に関するドメインサービスを作り、
そこでフィルターした Items を取得すべきだと思う。

<br>

## 課題 4 (DDD に関するクイズ)

### Q1

集約ルートに深い階層を持つプロパティがある場合、それだけを更新するメソッドを作りたくなる気がしますが、それは DDD の集約の原則に反するようです。
もし集約内の一部のプロパティを更新するメソッドを作った場合、どのようなデメリットがあると考えられますか？

### Q2

会計システムにおける伝票(`Receipt`)と伝票明細(`ReceiptDetail`)を表現するドメインオブジェクトを作成してください。
`Receipt`は会計金額を持ち、会計単位で作成されます。
`ReceiptDetail`は商品 id、商品単価、購入数量を持ち、会計で購入した商品単位で作成されます。
`Receipt`の会計金額は「各`ReceiptDetail`の 商品単価 \* 数量 の合計」という整合性を持ちます。

<br>

## 参考記事 & メモ

- [DDD オンライン勉強会 #2「集約」 - YouTube](https://glowing-bagpipe-856.notion.site/DDD-2-YouTube-0cc57b7982474a078b939328da196642)
- [境界づけられたコンテキスト 概念編 - ドメイン駆動設計用語解説 [DDD] - little hands' lab](https://little-hands.hatenablog.com/entry/2017/11/28/bouded-context-concept)

- [集約の実装について考えてみた](https://zenn.dev/takashi_onawa/articles/4648332c035d97)

  - 階層の深いプロパティは別集約にしていたが、親の集約と子の集約の整合性の担保を利用側に任せることになる
  - そもそも親の集約リポジトリで子の集約リポジトリを操作していたので、微妙っぽい？

- [DDD を実践するための手引き（リポジトリパターン編）](https://zenn.dev/kohii/articles/e4f325ed011db8)

  - もし仮に updateTitleById(id: TaskId) のようなメソッドをリポジトリに作ってしまうと、個別のビジネスロジックがリポジトリの実装（具体的には SQL の UPDATE 文など）に漏れ出てしまう。エンティティの状態の整合性を保証するのはエンティティの責務だが、SQL で個別に更新するとそれを破壊する可能性がある。同様の理由で、エンティティの更新日時をリポジトリの実装や DB 側で自動で設定する、みたいなのも NG です。テーブルの列定義の DEFAULT 句などの利用も避けましょう。考え方としては「リポジトリがエンティティの状態を更新する」のではなく、「エンティティ自身のふるまいによって状態が変更され、そのときの状態をリポジトリを使ってセーブしておく」という感じです。

  → 「個別のビジネスロジックがリポジトリの実装（具体的には SQL の UPDATE 文など）に漏れ出てしまう」のはなぜ？
